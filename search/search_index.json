{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lizard","text":"<p>Lizard is a domain-specific language to define hardware behavior. It is intended to run on embedded systems which are connected to motor controllers, sensors etc. Most of the time it is used in combination with a higher level engine like ROS or RoSys. You can think of the microcontroller as the machine's lizard brain which ensures basic safety and performs all time-critical actions.</p> <p>The idea is to not compile and deploy specific C++ code for every new hardware requirement. Instead you simply write your commands in a text-based language which can be changed on the fly.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Shell-like input and output over serial communication to ease the development</li> <li>Quick and resource-efficient execution on embedded hardware</li> <li>Built-in checksums to detect transmission errors</li> <li>Safety conditions that are checked continuously</li> <li>Ability to work across multiple microcontrollers</li> <li>Human-readable and easy-to-type (like Python)</li> <li>Persistent \"startup\" commands to apply configuration after boot</li> </ul>"},{"location":"#concept","title":"Concept","text":"<p>Lizard consists of individual hardware modules that are either defined in a persistent startup script or interactively via console input. Each module has a name, a number of required or optional constructor arguments and possibly a step function as well as a number of properties.</p> <p>Furthermore, Lizard allows to define rules, possibly asynchronous routines and variables. A routine is simply a collection of Lizard statements. If a rule's condition evaluates to true, the corresponding routine is started. Conditions can involve variables, module properties and constant expressions.</p> <p>One <code>core</code> module is automatically defined first. It provides interaction with the microcontroller itself, e.g. reading the system's time or causing a restart.</p> <p>During a main loop Lizard repeatedly performs the following tasks:</p> <ol> <li>Read and evaluate input from the serial interface.</li> <li>Run the step functions of each module. (The <code>core</code> module is evaluated last.)</li> <li>Check all rules and execute associated routines.</li> <li>Advance routines that are already running and waiting for certain conditions.</li> </ol>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#turn-on-an-led","title":"Turn on an LED","text":"<p>Create a new LED \"green\" at pin 14 and turn it on:</p> <pre><code>green = Output(14)\ngreen.on()\n</code></pre>"},{"location":"examples/#read-a-button","title":"Read a button","text":"<p>Create a button \"b1\" at pin 25 with internal pull-up resistor and read its value:</p> <pre><code>b1 = Input(25)\nb1.pullup()\nb1.level\n</code></pre>"},{"location":"examples/#write-a-persistent-startup-script","title":"Write a persistent startup script","text":"<p>Clear the persistent storage, configure a button and an LED, write the new startup script to the persistent storage, restart the microcontroller with these two new modules and print the stored configuration:</p> <pre><code>!-\n!+green = Output(14)\n!+b1 = Input(25)\n!.\ncore.restart()\n!?\n</code></pre>"},{"location":"examples/#define-a-rule","title":"Define a rule","text":"<p>Create an LED \"red\", a button \"b1\" with pull-up resistor as well as a condition \"c1\" that turns off the LED as soon as the button is pressed:</p> <pre><code>red = Output(14)\nred.on()\nb1 = Input(25)\nb1.pullup()\nwhen b1.level == 0 then red.off(); end\n</code></pre>"},{"location":"examples/#create-a-shadow-module","title":"Create a shadow module","text":"<p>Create a \"green\" LED that shadows a \"red\" LED, i.e. will receive a copy of each command:</p> <pre><code>green = Output(13)\nred = Output(14)\nred.shadow(green)\n</code></pre>"},{"location":"examples/#use-a-port-expander","title":"Use a port expander","text":"<p>Create a serial connection as well as a port expander with an LED at pin 15 and turn it on:</p> <pre><code>serial = Serial(26, 27, 11500, 1)\nexpander = Expander(serial, 32, 33)\nled = expander.Output(15)\nled.on()\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<ol> <li>Download and unpack the zip file of the latest release.</li> <li>Attach an Espressif ESP32 microcontroller via serial to your computer.</li> <li>Run <code>sudo ./flash.py /dev/&lt;serial device name&gt;</code> to install Lizard on the ESP32.</li> </ol>"},{"location":"getting_started/#try-out","title":"Try Out","text":"<p>You can launch an interactive shell with <code>./monitor.py</code> to try out configurations and watch Lizard outputs (see tools for more details). To verify that the communication is working, use one of the following commands to generate some output:</p> <pre><code>core.info()\ncore.millis\ncore.print(\"Hello, Lizard!\")\n</code></pre> <p>See the module reference for other commands.</p> <p>To try out individual modules, you can get their current properties or unmute them for continuous output, e.g.:</p> <pre><code>estop = Input(34)\nestop.level\nestop.unmute()\n</code></pre>"},{"location":"getting_started/#wiring","title":"Wiring","text":"<p>Of course you should connect the ESP32 to some hardware you want to control. From basic pins like LEDs (see Output) and buttons (see Input) to communication via CAN and control of stepper motors.</p>"},{"location":"getting_started/#startup-script","title":"Startup Script","text":"<p>You can create a startup script for rules which should be directly applied after boot of the microcontroller. Simply write the commands into a file like <code>on_startup.lizard</code> and set them with</p> <pre><code>./configure.py on_startup.lizard /dev/&lt;serial device name&gt;\n</code></pre> <p>See Tools for more details.</p>"},{"location":"language/","title":"The Lizard Language","text":""},{"location":"language/#statements","title":"Statements","text":"<p>Statements are input via the command-line interface or stored in the startup script on the microcontroller. The following statement types are currently supported.</p> <p>Expressions</p> <p>An expression can be a constant value, a variable, a module property, an arithmetic or logical expression as well as various combinations:</p> <pre><code>true\n42\n3.14\n\"Hello world\"\nled\nbutton.level\n1 + (2 - 3 * 4)**5\n1 == 2 or (x == 4 and button.level == 0)\n</code></pre> <p>Expressions can be assigned to variables, used in conditions and passed to constructors, method calls or routine calls. Plain expression statements print their result to the command line.</p> <p>Variables: declaration and assignment</p> <p>New variables need to be explicitly declared with a data type:</p> <pre><code>int i\n</code></pre> <p>They can be immediately initialized:</p> <pre><code>int i = 1\n</code></pre> <p>Otherwise they have an initial value of <code>false</code>, <code>0</code>, <code>0.0</code> or <code>\"\"</code>, respectively.</p> <p>Variables can be assigned a new value of compatible data type:</p> <pre><code>i = 2\n</code></pre> <p>Modules: constructors, method calls and property assignments</p> <p>Constructors are used to create module instances:</p> <pre><code>led = Output(15)\n</code></pre> <p>See the module reference for more details about individual modules and their argument lists.</p> <p>Constructors can also be used with expander modules to instantiate a remote module that can be controlled from the main microcontroller:</p> <pre><code>led = expander.Output(15)\n</code></pre> <p>You can call module methods as follows:</p> <pre><code>led.on()\n</code></pre> <p>Some module properties are meant to be written to:</p> <pre><code>motor.reversed = true\n</code></pre> <p>Routines: definition and call</p> <p>Routines have a name and contain a list of actions:</p> <pre><code>let all_on do\n    green.on()\n    red.on()\nend\n</code></pre> <p>They can be called similar to module methods:</p> <pre><code>all_on()\n</code></pre> <p>Rules: definition</p> <p>Rules execute a list of actions when a condition is met:</p> <pre><code>when button.level == 0 then\n    core.print(\"Off!\")\n    led.off()\nend\n</code></pre> <p>In contrast to an if-statement known from other languages a when-condition is checked in every cycle of Lizard's main loop. Whenever the condition is true, the actions are executed.</p> <p>Note that actions can be asynchronous. If there are still actions running asynchronously, a truthy condition is ignored.</p>"},{"location":"language/#actions","title":"Actions","text":"<p>Routines and rules contain a list of actions.</p> <p>Method and routine calls</p> <p>Like with a method call statement, you can call methods and routines with an action:</p> <pre><code>when clicked then\n    core.print(\"On!\")\n    all_on()\nend\n</code></pre> <p>Property and variable assignments</p> <p>Like with the corresponding assignment statements, you can assign properties and variables with an action as well:</p> <pre><code>when i &gt; 0 then\n    i = 0\n    core.debug = true\nend\n</code></pre> <p>Await conditions and routines</p> <p>In contrast to statements, actions can await conditions, causing the execution of subsequent actions to wait until the condition is met.</p> <pre><code>int t\nlet blink do\n    t = core.millis\n    led.on()\n    await core.millis &gt; t + 1000\n    led.off()\nend\n</code></pre> <p>Similarly, actions can await asynchronous routines, causing subsequent actions to wait until a routine is completed.</p> <pre><code>when button.level == 0 then\n    core.print(\"Blink...\")\n    await blink()\n    core.print(\"Done.\")\nend\n</code></pre>"},{"location":"language/#data-types","title":"Data types","text":"<p>Lizard currently supports five data types:</p> Data type Example Range boolean <code>bool b = true</code> <code>false</code>, <code>true</code> integer number <code>int i = 0</code> 64-bit unsigned integer floating point number <code>float f = 0.0</code> 64-bit float string <code>str s = \"foo\"</code> identifier <code>led = Output(15)</code> <p>Note that identifiers cannot be created via variable declarations, but only via constructors.</p> <p>Implicit conversion only happens from integers to floating point numbers:</p> <pre><code>int i = 42\nfloat f = i + 3.14\n</code></pre>"},{"location":"language/#whitespace-comments-and-line-breaks","title":"Whitespace, comments and line breaks","text":"<p>Tabs and spaces are treated as whitespace.</p> <p>Blank lines are interpreted as no-op and do nothing.</p> <p>Line comments start with <code>#</code>.</p> <p>Multiple statements or actions are separated with <code>;</code> or a newline.</p>"},{"location":"language/#control-commands","title":"Control commands","text":"<p>Lines with a leading <code>!</code> can indicate one of the following control commands.</p> Command Meaning <code>!+abc</code> Add <code>abc</code> to the startup script <code>!-abc</code> Remove lines starting with <code>abc</code> from the startup script <code>!?</code> Print the startup script <code>!.</code> Write the startup script to non-volatile storage <code>!!abc</code> Interpret <code>abc</code> as Lizard code <code>!\"abc</code> Print <code>abc</code> to the command-line <p>Note that the commands <code>!+</code>, <code>!-</code> and <code>!?</code> affect the startup script in RAM, which is only written to non-volatile storage with the <code>!.</code> command.</p> <p>Input from the default command-line interface UART0 is usually interpreted as Lizard code; input from a port expander is usually printed to the command-line on UART0. This behavior can be changed using <code>!!</code> and <code>!\"</code>.</p>"},{"location":"machine_safety/","title":"Machine Safety","text":"<p>Lizard implements the following features to increase machine safety.</p>"},{"location":"machine_safety/#checksums","title":"Checksums","text":"<p>Each line sent via the command-line interface can and should be followed by a checksum. Lizard will omit any lines with incorrect checksums. Any output is as well sent with a checksum.</p> <p>The 8-bit checksum is computed as the bitwise XOR of all characters excluding the newline character and written as a two-digit hex number (with leading zeros) separated with an <code>@</code> character, for example:</p> Line Bitwise XOR Result <code>1 + 2</code> 0x31 ^ 0x20 ^ 0x2b ^ 0x20 ^ 0x32 = 0x28 <code>1 + 2@28</code>"},{"location":"machine_safety/#keep-alive-signal","title":"Keep-alive signal","text":"<p>The <code>core</code> module provides a property <code>last_message_age</code>, which holds the time in milliseconds since the last input message was received from UART0, parsed and successfully interpreted. It allows formulating rules that stop critical hardware modules when the connection to the host system is lost.</p> <p>The following example stops a motor when there is no serial communication for 500 ms:</p> <pre><code>when core.last_message_age &gt; 500 then motor.stop(); end\n</code></pre>"},{"location":"machine_safety/#expander-watchdog","title":"Expander watchdog","text":"<p>The <code>expander</code> module provides a watchdog feature that restarts the port expander when it gets stuck and does not send messages anymore. After <code>ping_interval</code> seconds of no messages from the port expander, the <code>expander</code> module will instruct the expander to send a \"__PONG__\" message. If the expander does not answer within <code>ping_timeout</code> seconds, it will be restarted.</p> <p>The reception of the \"__PONG__\" message is handled internally by the expander module and is not printed to the serial output. A similar technique can be used by the main computing unit to check if the core microcontroller is still responsive and restart it otherwise.</p> <p>If a <code>proxy</code> module is active, the <code>ping_interval</code> will never elapse, because the <code>expander</code> module receives messages via the proxy message handling. Thus it will not need to ping the expander explicitly.</p>"},{"location":"module_reference/","title":"Module Reference","text":"<p>All Lizard modules have the following methods in common.</p> Methods Description <code>module.mute()</code> Turn output off <code>module.unmute()</code> Turn output on <code>module.shadow()</code> Send all method calls also to another module <code>module.broadcast()</code> Regularly send properties to another microcontroller (for internal use) <p>Shadows are useful if multiple modules should behave exactly the same, e.g. two actuators that should always move synchronously.</p> <p>The <code>broadcast</code> method is used internally with port expanders.</p>"},{"location":"module_reference/#core","title":"Core","text":"<p>The core module encapsulates various properties and methods that are related to the microcontroller itself. It is automatically created right after the boot sequence.</p> Properties Description Data type <code>core.debug</code> Whether to output debug information to the command line <code>bool</code> <code>core.millis</code> Time since booting the microcontroller (ms) <code>int</code> <code>core.heap</code> Free heap memory (bytes) <code>int</code> Methods Description Arguments <code>core.restart()</code> Restart the microcontroller <code>core.version()</code> Show lizard version <code>core.info()</code> Show lizard version, compile time and IDF version <code>core.print(...)</code> Print arbitrary arguments to the command line arbitrary <code>core.output(format)</code> Define the output format <code>str</code> <code>core.startup_checksum()</code> Show 16-bit checksum of the startup script <code>core.ota(ssid, password, url)</code> Starts OTA update on a URL with given WiFi 3x <code>str</code> <code>core.get_pin_status(pin)</code> Print the status of the chosen pin <code>int</code> <code>core.set_pin_level(pin, value)</code> Turns the pin into an output and sets its level <code>int</code>, <code>int</code> <code>core.get_pin_strapping(pin)</code> Print value of the pin from the strapping register <code>int</code> <p>The output <code>format</code> is a string with multiple space-separated elements of the pattern <code>&lt;module&gt;.&lt;property&gt;[:&lt;precision&gt;]</code> or <code>&lt;variable&gt;[:&lt;precision&gt;]</code>. The <code>precision</code> is an optional integer specifying the number of decimal places for a floating point number. For example, the format <code>\"core.millis input.level motor.position:3\"</code> might yield an output like <code>\"92456 1 12.789\"</code>.</p> <p>The OTA update will try to connect to the specified WiFi network with the provided SSID and password. After initializing the WiFi connection, it will attempt an OTA update from the given URL. Upon successful updating, the ESP will restart and attempt to verify the OTA update. It will reconnect to the WiFi and try to access URL + <code>/verify</code> to receive a message with the current version of Lizard. The test is considered successful if an HTTP request is received, even if the version does not match or is empty. If the newly updated Lizard cannot connect to URL + <code>/verify</code>, the OTA update will be rolled back.</p> <p><code>core.get_pin_status(pin)</code> reads the pin's voltage, not the output state directly.</p>"},{"location":"module_reference/#bluetooth","title":"Bluetooth","text":"<p>Lizard can receive messages via Bluetooth Low Energy, and also send messages in return to a connected device. Simply create a Bluetooth module with a device name of your choice.</p> Constructor Description Arguments <code>bluetooth = Bluetooth(device_name)</code> initialize bluetooth with advertised <code>device_name</code> <code>str</code> Methods Description Arguments <code>bluetooth.send(data)</code> send <code>data</code> via notification <code>str</code> <p>Lizard will offer a service 23014CCC-4677-4864-B4C1-8F772B373FAC and a characteristic 37107598-7030-46D3-B688-E3664C1712F0 that allows writing Lizard statements like on the command line. On a second characteristic 19f91f52-e3b1-4809-9d71-bc16ecd81069 notifications will be emitted when <code>send(data)</code> is executed.</p>"},{"location":"module_reference/#input","title":"Input","text":"<p>The input module is associated with a digital input pin that is be connected to a pushbutton, sensor or other input signal.</p> Constructor Description Arguments <code>input = Input(pin)</code> <code>pin</code> is the corresponding GPIO number <code>int</code> Properties Description Data type <code>input.level</code> Current signal level (0 or 1) <code>int</code> <code>input.change</code> Level change since last cycle (-1..1) <code>int</code> <code>input.inverted</code> Inverts the active property if true <code>bool</code> <code>input.active</code> Current active state of the input <code>bool</code> <p>Usually, an input is considered active if and only if its level is high. If the <code>inverted</code> property is set to <code>true</code>, the input is considered active if and only if its level is low.</p> Methods Description <code>input.get()</code> Output the current level <code>input.pullup()</code> Add an internal pull-up resistor <code>input.pulldown()</code> Add an internal pull-down resistor <code>input.pulloff()</code> Remove internal pull resistor"},{"location":"module_reference/#output","title":"Output","text":"<p>The output module is associated with a digital output pin that is connected to an LED, actuator or other output signal.</p> Constructor Description Arguments <code>output = Output(pin)</code> <code>pin</code> is the corresponding GPIO number <code>int</code> Properties Description Data type <code>output.level</code> Current signal level (0 or 1) <code>int</code> <code>output.change</code> Level change since last cycle (-1..1) <code>int</code> <code>output.enabled</code> Whether the output is enabled <code>bool</code> <code>output.inverted</code> Whether the output is inverted <code>bool</code> <code>output.active</code> Whether the output is active <code>bool</code> <p>Usually, an output is considered active if and only if its level is high. If the <code>inverted</code> property is set to <code>true</code>, the output is considered active if and only if its level is low.</p> Methods Description Arguments <code>output.on()</code> Set the output pin high <code>output.off()</code> Set the output pin low <code>output.level(value)</code> Set the output level to the given <code>value</code> <code>bool</code> <code>output.pulse(interval[, duty_cycle])</code> Switch output on and off <code>float</code>s <code>output.enable()</code> Enable the output <code>output.disable()</code> Disable the output <code>output.activate()</code> Activate the output <code>output.deactivate()</code> Deactivate the output <p>The <code>pulse()</code> method allows pulsing an output with a given interval in seconds and an optional duty cycle between 0 and 1 (0.5 by default). Note that the pulsing frequency is limited by the main loop to around 20 Hz.</p> <p>When the output is disabled, it will deactivate and ignore on/off or level commands.</p>"},{"location":"module_reference/#pwm-output","title":"PWM Output","text":"<p>The PWM output module is associated with a digital output pin that is connected to an LED, actuator or other output signal.</p> Constructor Description Arguments <code>pwm = PwmOutput(pin)</code> <code>pin</code> is the corresponding GPIO number <code>int</code> Properties Description Data type <code>output.duty</code> Duty cycle (8 bit: 0..256, default: 128) <code>int</code> <code>output.frequency</code> Frequency (Hz, default: 1000) <code>int</code> <code>output.enabled</code> Whether the output is enabled <code>bool</code> Methods Description Arguments <code>output.on()</code> Turn on the PWM signal <code>output.off()</code> Turn off the PWM signal <code>output.enable()</code> Enable the PWM output <code>output.disable()</code> Disable the PWM output <p>When the output is disabled, it will turn off the PWM signal and ignore on/off commands.</p>"},{"location":"module_reference/#mcp23017-port-expander","title":"MCP23017 Port Expander","text":"<p>The MCP23017 allows controlling up to 16 general purpose input or output pins via I2C.</p> Constructor Description Arguments <code>mcp = Mcp23017([port[, sda[, scl[, address[, clk_speed]]]]])</code> See below <code>int</code>s <p>The constructor expects up to five arguments:</p> <ul> <li><code>port</code>: 0 or 1, since the ESP32 has two I2C ports (default: 0)</li> <li><code>sda</code>: SDA pin (default: 21)</li> <li><code>scl</code>: SCL pin (default: 22)</li> <li><code>address</code>: client address of the MCP (0x20..0x28, default: 0x20)</li> <li><code>clk_speed</code>: I2C clock speed (default: 100000)</li> </ul> Properties Description Data type <code>mcp.levels</code> Levels of all 16 pins <code>int</code> <code>mcp.inputs</code> Input mode of all 16 pins <code>int</code> <code>mcp.pullups</code> Pull-up resistors for all 16 pins <code>int</code> <p>The properties <code>levels</code>, <code>inputs</code> and <code>pullups</code> contain binary information for all 16 pins in form of a 16 bit unsigned integer.</p> Methods Description Arguments <code>mcp.levels(value)</code> Set levels of all 16 pins <code>int</code> <code>mcp.inputs(value)</code> Set input mode of all 16 pins <code>int</code> <code>mcp.pullups(value)</code> Set pull-up resistors for all 16 pins <code>int</code> <p>The methods <code>levels()</code>, <code>inputs()</code> and <code>pullups()</code> expect a 16 bit unsigned integer <code>value</code> containing binary information for all 16 pins.</p> <p>Use <code>inputs()</code> to configure input and output pins, e.g. <code>inputs(0xffff)</code> all inputs or <code>inputs(0x0000)</code> all outputs. While <code>levels()</code> will only affect output pins, <code>pullups()</code> will only affect the levels of input pins.</p> <p>Using an MCP23017 port expander module you can not only access individual pins. You can also instantiate the following modules passing the <code>mcp</code> instance as the first argument:</p> <ul> <li>Input: <code>input = Input(mcp, pin)</code></li> <li>Output: <code>output = Output(mcp, pin)</code></li> <li>Linear motor: <code>motor = LinearMotor(mcp, move_in, move_out, end_in, end_out)</code></li> </ul> <p>The pins <code>pin</code>, <code>move_in</code>, <code>move_out</code>, <code>end_in</code> and <code>end_out</code> are numbers from 0 to 15 referring to A0...A7 and B0...B7 on the MCP23017.</p>"},{"location":"module_reference/#imu","title":"IMU","text":"<p>The IMU module provides access to a Bosch BNO055 9-axis absolute orientation sensor. Currently, only reading the accelerometer is implemented.</p> Constructor Description Arguments <code>imu = Imu([port[, sda[, scl[, address[, clk_speed]]]]])</code> See below <code>int</code>s <p>The constructor expects up to five arguments:</p> <ul> <li><code>port</code>: 0 or 1, since the ESP32 has two I2C ports (default: 0)</li> <li><code>sda</code>: SDA pin (default: 21)</li> <li><code>scl</code>: SCL pin (default: 22)</li> <li><code>address</code>: client address of the MCP (0x28 or 0x29, default: 0x28)</li> <li><code>clk_speed</code>: I2C clock speed (default: 100000)</li> </ul> Properties Description Data type <code>imu.cal_sys</code> calibration: system (0 to 3) <code>int</code> <code>imu.cal_gyr</code> calibration: gyroscope (0 to 3) <code>int</code> <code>imu.cal_acc</code> calibration: accelerometer (0 to 3) <code>int</code> <code>imu.cal_mag</code> calibration: magnetometer (0 to 3) <code>int</code> <code>imu.acc_x</code> acceleration incl. gravity: x direction (m/s^2) <code>float</code> <code>imu.acc_y</code> acceleration incl. gravity: y direction (m/s^2) <code>float</code> <code>imu.acc_z</code> acceleration incl. gravity: z direction (m/s^2) <code>float</code> <code>imu.mag_x</code> magnetic field strength: x direction (\u00b5T) <code>float</code> <code>imu.mag_y</code> magnetic field strength: y direction (\u00b5T) <code>float</code> <code>imu.mag_z</code> magnetic field strength: z direction (\u00b5T) <code>float</code> <code>imu.gyr_x</code> gyroscope: x direction (degrees/s) <code>float</code> <code>imu.gyr_y</code> gyroscope: y direction (degrees/s) <code>float</code> <code>imu.gyr_z</code> gyroscope: z direction (degrees/s) <code>float</code> <code>imu.yaw</code> orientation: Euler angle yaw (degrees) <code>float</code> <code>imu.roll</code> orientation: Euler angle roll (degrees) <code>float</code> <code>imu.pitch</code> orientation: Euler angle pitch (degrees) <code>float</code> <code>imu.quat_w</code> orientation: quaternion component w <code>float</code> <code>imu.quat_x</code> orientation: quaternion component x <code>float</code> <code>imu.quat_y</code> orientation: quaternion component y <code>float</code> <code>imu.quat_z</code> orientation: quaternion component z <code>float</code> <code>imu.lin_x</code> acceleration excl. gravity: x direction (m/s^2) <code>float</code> <code>imu.lin_y</code> acceleration excl. gravity: y direction (m/s^2) <code>float</code> <code>imu.lin_z</code> acceleration excl. gravity: z direction (m/s^2) <code>float</code> <code>imu.grav_x</code> gravity: x direction (m/s^2) <code>float</code> <code>imu.grav_y</code> gravity: y direction (m/s^2) <code>float</code> <code>imu.grav_z</code> gravity: z direction (m/s^2) <code>float</code> <code>imu.temp</code> temperature (degrees Celsius) <code>int</code> <code>imu.data_select</code> data selection <code>int</code> <p>The <code>data_select</code> property can be used to select which data is read from the IMU. The default value is 0xffff, which means all data is read. The following bits are available:</p> <ul> <li>0x0001: calibration status</li> <li>0x0002: accelerometer data</li> <li>0x0004: magnetometer data</li> <li>0x0008: gyroscope data</li> <li>0x0010: Euler angles</li> <li>0x0020: quaternion</li> <li>0x0040: linear acceleration</li> <li>0x0080: gravity</li> <li>0x0100: temperature</li> </ul> Methods Description Arguments <code>imu.set_mode(mode)</code> Set operation mode of the IMU <code>str</code> <p>The <code>mode</code> parameter can be one of the following:</p> Mode Accel Mag Gyro Relative Orientation Absolute Orientation <code>configmode</code> - - - - - <code>acconly</code> X - - - - <code>magonly</code> - X - - - <code>gyroonly</code> - - X - - <code>accmag</code> X X - - - <code>accgyro</code> X - X - - <code>maggyro</code> - X X - - <code>amg</code> X X X - - <code>imu</code> X - X X - <code>compass</code> X X - - X <code>m4g</code> X X X - <code>ndof_fmc_off</code> X X X - X <code>ndof</code> X X X - X <p>In non-fusion modes (<code>acconly</code>, <code>magonly</code>, <code>gyroonly</code>, <code>accmag</code>, <code>accgyro</code>, <code>maggyro</code>, <code>amg</code>), the sensor signals (Accel, Mag, Gyro) are uncompensated and fusion data (Relative and Absolute Orientation) is not available.</p> <p>In fusion modes (<code>imu</code>, <code>compass</code>, <code>m4g</code>, <code>ndof_fmc_off</code>, <code>ndof</code>), the sensor signals (Accel, Mag, Gyro) are compensated and fusion data (Relative and Absolute Orientation) is available.</p> <p>Note that the individual sensors need to be calibrated before the compensated and fused data is accurate.</p> Sensor Calibration Accelerometer Position the sensor in 6 different stable orientations Magnetometer Move the sensor in a figure-8 pattern in space Gyroscope Keep the sensor still for a few seconds"},{"location":"module_reference/#can-interface","title":"CAN interface","text":"<p>The CAN module allows communicating with peripherals on the specified CAN bus.</p> Constructor Description Arguments <code>can = Can(rx, tx, baud)</code> RX/TX pins and baud rate <code>int</code>, <code>int</code>, <code>int</code> Methods Description Arguments <code>can.send(node_id, d0, d1, d2, d3, d4, d5, d6, d7)</code> Send a frame with 8 data bytes 9x <code>int</code> <code>can.get_status()</code> Print the driver status <code>can.start()</code> Start the driver <code>can.stop()</code> Stop the driver <code>can.recover()</code> Recover the driver <code>can.reset()</code> Reset the driver <p>The method <code>get_status()</code> prints the following information:</p> <ul> <li><code>state</code> (\"STOPPED\", \"RUNNING\", \"BUS_OFF\" or \"RECOVERING\"),</li> <li><code>msgs_to_tx</code>,</li> <li><code>msgs_to_rx</code>,</li> <li><code>tx_error_counter</code>,</li> <li><code>rx_error_counter</code>,</li> <li><code>tx_failed_count</code>,</li> <li><code>rx_missed_count</code>,</li> <li><code>rx_overrun_count</code>,</li> <li><code>arb_lost_count</code> and</li> <li><code>bus_error_count</code>.</li> </ul> <p>After creating a CAN module, the driver is started automatically. The <code>start()</code> and <code>stop()</code> methods are primarily for debugging purposes.</p> <p>The <code>recover()</code> method can be used to recover the driver from a \"BUS_OFF\" state. In contrast, the <code>reset()</code> method will stop the driver, try to recover it and then start it again.</p>"},{"location":"module_reference/#serial-interface","title":"Serial interface","text":"<p>The serial module allows communicating with peripherals via the specified connection.</p> Constructor Description Arguments <code>serial = Serial(rx, tx, baud, num)</code> RX/TX pins, baud rate, UART number 4x <code>int</code> Methods Description Arguments <code>serial.send(b0, b1, b2, ...)</code> Send a number of bytes <code>int</code>s <code>serial.read()</code> Read and output current buffer <p>This module might be used by other modules that communicate with peripherals via serial. You can, however, unmute the serial module to have incoming messages printed to the command line instead of keeping them buffered for other modules.</p>"},{"location":"module_reference/#linear-motor","title":"Linear motor","text":"<p>This module controls a linear actuator via two output pins (move in, move out) and two input pins reading two limit switches (end in, end out).</p> Constructor Description Arguments <code>motor = LinearMotor(move_in, move_out, end_in, end_out)</code> motor control pins and limit switches 4x <code>int</code> Properties Description Data type <code>motor.in</code> Motor is in \"in\" position <code>bool</code> <code>motor.out</code> Motor is in \"out\" position <code>bool</code> <code>motor.enabled</code> Whether the motor is enabled <code>bool</code> Methods Description <code>motor.in()</code> Move in <code>motor.out()</code> Move out <code>motor.stop()</code> Stop the motor <code>motor.enable()</code> Enable the motor <code>motor.disable()</code> Disable the motor <p>When the motor is disabled, it will stop and ignore in/out commands.</p>"},{"location":"module_reference/#odrive-motor","title":"ODrive Motor","text":"<p>The ODrive motor module controls a motor using an ODrive motor controller.</p> Constructor Description Arguments <code>motor = ODriveMotor(can, can_id[, version])</code> CAN module, node ID and version CAN module, <code>int</code>, <code>int</code> <p>The <code>version</code> parameter is an optional integer indicating the patch number of the ODrive firmware (4, 5 or 6; default: 4 for version \"0.5.4\"). Version 0.5.6 allows to read the motor error flag.</p> Properties Description Data type <code>motor.position</code> Motor position (meters) <code>float</code> <code>motor.speed</code> Motor speed (m/s) <code>float</code> <code>motor.tick_offset</code> Encoder tick offset <code>float</code> <code>motor.m_per_tick</code> Meters per encoder tick <code>float</code> <code>motor.reversed</code> Reverse motor direction <code>bool</code> <code>motor.axis_state</code> State of the motor axis <code>int</code> <code>motor.axis_error</code> Error code of the axis <code>int</code> <code>motor.motor_error</code> Motor error flat (requires version 0.5.6) <code>int</code> <code>motor.enabled</code> Whether the motor is enabled <code>bool</code> Methods Description Arguments <code>motor.zero()</code> Set current position as zero position <code>motor.power(torque)</code> Move with given <code>torque</code> <code>float</code> <code>motor.speed(speed)</code> Move with given <code>speed</code> (m/s) <code>float</code> <code>motor.position(position)</code> Move to given <code>position</code> (m) <code>float</code> <code>motor.limits(speed, current)</code> Set speed (m/s) and current (A) limits <code>float</code>, <code>float</code> <code>motor.off()</code> Turn motor off (idle state) <code>motor.reset_motor()</code> Resets the motor and clears errors <code>motor.enable()</code> Enable the motor <code>motor.disable()</code> Disable the motor <code>motor.stop()</code> Stop the motor <p>When the motor is disabled, it will stop and ignore movement commands.</p>"},{"location":"module_reference/#odrive-wheels","title":"ODrive Wheels","text":"<p>The ODrive wheels module combines two ODrive motors and provides odometry and steering for differential wheeled robots.</p> Constructor Description Arguments <code>wheels = ODriveWheels(left_motor, left_motor)</code> Two ODrive motor modules two ODrive motor modules Properties Description Data type <code>wheels.width</code> Wheel distance (m) <code>float</code> <code>wheels.linear_speed</code> Forward speed (m/s) <code>float</code> <code>wheels.angular_speed</code> Turning speed (rad/s) <code>float</code> <code>wheels.enabled</code> Whether the wheels are enabled <code>bool</code> Methods Description Arguments <code>wheels.power(left, right)</code> Move with torque per wheel <code>float</code>, <code>float</code> <code>wheels.speed(linear, angular)</code> Move with <code>linear</code>/<code>angular</code> speed (m/s, rad/s) <code>float</code>, <code>float</code> <code>wheels.off()</code> Turn both motors off (idle state) <code>wheels.enable()</code> Enable both motors <code>wheels.disable()</code> Disable both motors <p>When the wheels are disabled, they will stop and ignore movement commands. This allows disabling the wheels permanently by setting <code>enabled = false</code> in conjunction with calling the <code>off()</code> method. Now the vehicle can be pushed manually with motors turned off, without taking care of every line of code potentially re-activating the motors.</p>"},{"location":"module_reference/#rmd-motor","title":"RMD Motor","text":"<p>The RMD motor module controls a MyActuator RMD motor via CAN.</p> Constructor Description Arguments <code>rmd = RmdMotor(can, motor_id, ratio)</code> CAN module, motor ID (1..8) and transmission ratio CAN module, <code>int</code>, <code>int</code> Properties Description Data type <code>rmd.position</code> Multi-turn motor position (deg) <code>float</code> <code>rmd.torque</code> Current torque <code>float</code> <code>rmd.speed</code> Current speed (deg/s) <code>float</code> <code>rmd.temperature</code> Current temperature (\u02daC) <code>float</code> <code>rmd.can_age</code> Time since last CAN message from motor (s) <code>float</code> <code>rmd.enabled</code> Whether the motor is enabled <code>bool</code> Methods Description Arguments <code>rmd.power(torque)</code> Move with given <code>torque</code> (-32..32 A) <code>float</code> <code>rmd.speed(speed)</code> Move with given <code>speed</code> (deg/s) <code>float</code> <code>rmd.position(pos)</code> Move to and hold at <code>pos</code> (deg) <code>float</code> <code>rmd.position(pos, speed)</code> Move to and hold at <code>pos</code> (deg) with max. <code>speed</code> (deg/s) <code>float</code>, <code>float</code> <code>rmd.stop()</code> Stop motor (but keep operating state) <code>rmd.off()</code> Turn motor off (clear operating state) <code>rmd.hold()</code> Hold current position <code>rmd.get_pid()</code> Print PID parameters Kp/Ki for position/speed/torque loop <code>rmd.set_pid(...)</code> Set PID parameters Kp/Ki for position/speed/torque loop 6x <code>int</code> <code>rmd.get_acceleration()</code> Print acceleration (deg/s^2) <code>rmd.set_acceleration(...)</code> Set accelerations/decelerations for position/speed loop (deg/s^2) 4x <code>int</code> <code>rmd.get_status()</code> Print temperature [\u02daC], voltage [V] and motor error code <code>rmd.clear_errors()</code> Clear motor error <code>rmd.enable()</code> Enable the motor <code>rmd.disable()</code> Disable the motor <p>When the motor is disabled, it will stop and ignore movement commands.</p> <p>Set acceleration</p> <p>Although <code>get_acceleration()</code> prints only one acceleration per motor, <code>set_acceleration</code> distinguishes the following four parameters:</p> <ol> <li>acceleration for position mode</li> <li>deceleration for position mode</li> <li>acceleration for speed mode</li> <li>deceleration for speed mode</li> </ol> <p>You can pass <code>0</code> to skip parameters, i.e. to keep individual acceleration values unchanged.</p>"},{"location":"module_reference/#rmd-motor-pair","title":"RMD Motor Pair","text":"<p>The RMD motor pair module allows to synchronize two RMD motors.</p> Constructor Description Arguments <code>rmd = RmdPair(rmd1, rmd2)</code> Two RMD motor modules 2x RMD Motor module Properties Description Data type <code>rmd.v_max</code> Maximum speed (deg/s, default: 360) <code>float</code> <code>rmd.a_max</code> Maximum acceleration (deg/s\u00b2 (default: 10000) <code>float</code> <code>rmd.enabled</code> Whether the motor pair is enabled <code>bool</code> Methods Description Arguments <code>rmd.move(x, y)</code> Move motor 1 to <code>x</code> and motor 2 to <code>x</code> 2x <code>float</code> <code>rmd.stop()</code> Stop motors (but keep operating state) <code>rmd.off()</code> Turn motors off (clear operating state) <code>rmd.hold()</code> Hold current positions <code>rmd.clear_errors()</code> Clear motor errors <code>rmd.enable()</code> Enable both motors <code>rmd.disable()</code> Disable both motors <p>When the motor pair is disabled, it will stop both motors and ignore movement commands.</p>"},{"location":"module_reference/#roboclaw","title":"RoboClaw","text":"<p>The RoboClaw module serves as building block for more complex modules like RoboClaw motors. It communicates with a Basicmicro RoboClaw motor driver via serial.</p> Constructor Description Arguments <code>claw = RoboClaw(serial, address)</code> Serial module and address Serial module, <code>int</code> Properties Description Data type <code>claw.temperature</code> Board temperature (degrees Celsius) <code>float</code> <p>The temperature property is updated every 1 second.</p>"},{"location":"module_reference/#roboclaw-motor","title":"RoboClaw Motor","text":"<p>The RoboClaw motor module controls a motor using a RoboClaw module.</p> Constructor Description Arguments <code>motor = RoboClawMotor(claw, motor_id)</code> RoboClaw module and motor ID (1..2) RoboClaw module, <code>int</code> Properties Description Data type <code>motor.position</code> Multi-turn motor position (encoder ticks) <code>int</code> <code>motor.enabled</code> Whether the motor is enabled <code>bool</code> Methods Description Arguments <code>motor.power(torque)</code> Move with given <code>torque</code> (-1..1) <code>float</code> <code>motor.speed(speed)</code> Move with given <code>speed</code> (-32767..32767) <code>float</code> <code>motor.zero()</code> Store position as zero position <code>motor.enable()</code> Enable the motor <code>motor.disable()</code> Disable the motor <p>When the motor is disabled, it will stop and ignore movement commands.</p>"},{"location":"module_reference/#roboclaw-wheels","title":"RoboClaw Wheels","text":"<p>The RoboClaw wheels module combines two RoboClaw motors and provides odometry and steering for differential wheeled robots.</p> Constructor Description Arguments <code>wheels = RoboClawWheels(left_motor, left_motor)</code> left and right motors two RoboClaw motor modules Properties Description Data type <code>wheels.width</code> Wheel distance (m) <code>float</code> <code>wheels.linear_speed</code> Forward speed (m/s) <code>float</code> <code>wheels.angular_speed</code> Turning speed (rad/s) <code>float</code> <code>wheels.m_per_tick</code> Meters per encoder tick <code>float</code> <code>wheels.enabled</code> Whether motors react to commands <code>bool</code> Methods Description Arguments <code>wheels.power(left, right)</code> Move with torque per wheel (-1..1) <code>float</code>, <code>float</code> <code>wheels.speed(linear, angular)</code> Move with <code>linear</code>/<code>angular</code> speed (m/s, rad/s) <code>float</code>, <code>float</code> <code>wheels.off()</code> Turn both motors off (idle state) <code>wheels.enable()</code> Enable both motors <code>wheels.disable()</code> Disable both motors <p>When the wheels are disabled, they will stop and ignore movement commands.</p>"},{"location":"module_reference/#stepper-motor","title":"Stepper Motor","text":"<p>The stepper motor module controls a stepper motor via \"step\" and \"direction\" pins. It uses the ESP LED Control API to generate pulses with sufficiently high frequencies and the Pulse Counter API to count steps.</p> Constructor Description Arguments <code>motor = StepperMotor(step, dir[, pu[, cp[, lt[, lc]]]])</code> Step and direction pins 6x <code>int</code> <p>The constructor arguments <code>pu</code> (pulse counter unit), <code>pc</code> (pulse counter channel), <code>lt</code> (LED timer) and <code>lc</code> (LED channel) are optional and default to 0. When using multiple stepper motors, they can be set to different values to avoid conflicts.</p> Properties Description Data type <code>motor.position</code> Motor position (steps) <code>int</code> <code>motor.speed</code> Motor speed (steps per second) <code>int</code> <code>motor.idle</code> Motor idle state <code>bool</code> <code>motor.enabled</code> Whether the motor is enabled <code>bool</code> Methods Description Arguments <code>motor.speed(speed[, acceleration])</code> Move with given <code>speed</code> 2x <code>float</code> <code>motor.position(position, speed[, acceleration])</code> Move to given <code>position</code> 3x <code>float</code> <code>motor.stop()</code> Stop <code>motor.enable()</code> Enable the motor <code>motor.disable()</code> Disable the motor <p>The optional acceleration argument defaults to 0, which starts and stops pulsing immediately.</p> <p>When the motor is disabled, it will stop and ignore movement commands.</p>"},{"location":"module_reference/#motor-axis","title":"Motor Axis","text":"<p>The motor axis module wraps a motor and two limit switches. It prevents the motor from moving past the limits. But in contrast to a simple Lizard rule, it allows to actively move out of the limits when moving in the right direction. Currently supported motor types are CanOpenMotor, ODriveMotor and StepperMotor.</p> Constructor Description Arguments <code>axis = MotorAxis(motor, limit1, limit2)</code> motor and input modules 3 modules Properties Description Data type <code>axis.enabled</code> Whether the motor axis is enabled <code>bool</code> <p>To get the current position or speed, access the motor module instead.</p> Methods Description Arguments <code>axis.speed(speed[, acceleration])</code> Move with given <code>speed</code> 2x <code>float</code> <code>axis.position(position, speed[, acceleration])</code> Move to given <code>position</code> 3x <code>float</code> <code>axis.stop()</code> Stop <code>axis.enable()</code> Enable the motor axis <code>axis.disable()</code> Disable the motor axis <p>When the motor axis is disabled, it will stop the motor and ignore movement commands.</p>"},{"location":"module_reference/#canopenmaster","title":"CanOpenMaster","text":"<p>The CanOpenMaster module sends periodic SYNC messages to all CANopen nodes. At creation, no messages are sent until <code>sync_interval</code> is set to a value greater than 0.</p> Constructor Description Arguments <code>co_master = CanOpenMaster(can)</code> CAN module CAN module Properties Description Data type <code>co_master.sync_interval</code> Amount of lizard steps in between each SYNC <code>int</code>"},{"location":"module_reference/#canopenmotor","title":"CanOpenMotor","text":"<p>The CanOpenMotor module implements a subset of commands necessary to control a motor implementing DS402. Positional and velocity units are currently undefined and must by manually measured. Once the configuration sequence has finished, current status, position and velocity are queried on every SYNC.</p> Constructor Description Arguments <code>motor = CanOpenMotor(can, node_id)</code> CAN module and node ID (1..127) CAN module, <code>int</code> Methods Description Arguments <code>motor.enter_pp_mode(velo)</code> Set 402 operating mode to profile position, halt off, and target velocity to <code>velo</code> <code>int</code> <code>motor.enter_pv_mode()</code> Set 402 operating mode to profile velocity, halt on, and target velocity to <code>velo</code> <code>int</code> <code>motor.set_target_position(pos)</code> Set target position to <code>pos</code> (signed). [pp mode] <code>int</code> <code>motor.commit_target_position()</code> Instruct motor to move to previously set target position. [pp mode] <code>motor.set_target_velocity(velo)</code> Set target velocity to <code>velo</code>. Absolute for pp mode, signed for pv mode <code>int</code> <code>motor.set_ctrl_halt(mode)</code> Latches / resets the \"halt\" bit and sends the updated control word to the node <code>bool</code> <code>motor.set_ctrl_enable(mode)</code> Latches / resets the \"enable operation\" bit and sends an updated control word to the node <code>bool</code> <code>motor.set_profile_acceleration(acceleration)</code> Sets the motor acceleration <code>int</code> <code>motor.set_profile_deceleration(deceleration)</code> Sets the motor deceleration <code>int</code> <code>motor.set_profile_quick_stop_deceleration(deceleration)</code> Sets the motor deceleration for the quick stop command <code>int</code> <code>motor.reset_fault()</code> Clear any faults (like positioning errors). Implicitly sets the \"halt\" bit. <code>motor.sdo_read(index)</code> Performs an SDO read at index <code>index</code> and sub index <code>0x00</code> <code>int</code> Properties Description Data type <code>initialized</code> Concurrent init sequence has finished, motor is ready <code>bool</code> <code>last_heartbeat</code> Time in \u00b5s since bootup when last heartbeat was received <code>int</code> <code>is_booting</code> Node is in booting state <code>bool</code> <code>is_preoperational</code> Node is in pre-operational state <code>bool</code> <code>is_operational</code> Node is in operational state <code>bool</code> <code>actual_position</code> Motor position at last SYNC <code>int</code> <code>position_offset</code> Offset implicitly added to target/reported position <code>int</code> <code>actual_velocity</code> Motor velocity at last SYNC <code>int</code> <code>status_enabled</code> Operation enabled bit of status word since last SYNC <code>bool</code> <code>status_fault</code> Fault bit of status word since last SYNC <code>bool</code> <code>status_target_reached</code> Target reached bit of status word since last SYNC <code>bool</code> <code>ctrl_enable</code> Latched operation enable bit of every sent control word <code>bool</code> <code>ctrl_halt</code> Latched halt bit of every sent control word <code>bool</code> <p>Configuration sequence</p> <p>After creation of the module, the configuration is stepped through automatically on each heartbeat; once finished, the <code>initialized</code> attribute is set to <code>true</code>. Note that for runtime variables (actual position, velocity, and status bits) to be updated, a CanOpenMaster module must exist and be sending periodic SYNCs.</p> <p>Target position sequence</p> <p>Note: The target velocity must be positive regardless of target point direction. The halt bit is cleared when entering pp, though it can be set at any point during moves to effectively apply brakes.</p> <pre><code>// First time, assuming motor is disabled and not in pp mode\nmotor.set_ctrl_enable(true)\nmotor.enter_pp_mode(&lt;some positive velocity&gt;)\n\n// All further set points only need these\nmotor.set_target_position(&lt;some position&gt;)\nmotor.commit_target_position()\n</code></pre> <p>Target velocity sequence</p> <p>Unlike in the profile position mode, here the sign of the velocity does controls the direction. The halt bit is set when entering pv. To start moving, clear it (and set again to stop).</p> <pre><code>// First time, assuming motor is disabled and not in pv mode\nmotor.set_ctrl_enable(true)\nmotor.enter_pv_mode(&lt;some signed velocity&gt;)\n\n// Further movements only need these\nmotor.set_ctrl_halt(false)\n// await some condition\nmotor.set_ctrl_halt(true)\n</code></pre>"},{"location":"module_reference/#d1-motor","title":"D1 Motor","text":"<p>This module controls an igus D1 motor controller via CANOpen.</p> Constructor Description Arguments <code>motor = D1Motor(can, node_id)</code> CAN module and node ID (1..127) CAN module, <code>int</code> Properties Description Data type <code>motor.switch_search_speed</code> Speed for moving into the end stop <code>int</code> <code>motor.zero_search_speed</code> Speed for moving out ot the end stop <code>int</code> <code>motor.homing_acceleration</code> Acceleration for homing <code>int</code> <code>motor.profile_acceleration</code> Acceleration for profile movements <code>int</code> <code>motor.profile_velocity</code> Velocity for profile position movements <code>int</code> <code>motor.profile_deceleration</code> Deceleration for profile movements <code>int</code> <code>motor.position</code> Current position <code>int</code> <code>motor.velocity</code> Current velocity <code>int</code> <code>motor.status_word</code> Status word <code>int</code> <code>motor.status_flags</code> Status flags <code>int</code> <code>motor.enabled</code> Whether the motor is enabled <code>bool</code> <p>Bit 0 of the status flags indicates the motor is referenced (1) or not (0).</p> <p>The status word (also called \"Statusword\") is a 16 bit integer with several flags. See the D1 manual for details.</p> Methods Description Arguments <code>motor.setup()</code> Setup (enable) the motor <code>motor.home()</code> Start homing the motor <code>motor.profile_position()</code> Move to given position <code>int</code> <code>motor.profile_velocity()</code> Move with given velocity <code>int</code> <code>motor.stop()</code> Stop (disable) the motor <code>motor.reset()</code> Reset motor errors <code>motor.sdo_read(index[, subindex])</code> Read SDO 2x <code>int</code> <code>motor.sdo_write(index, subindex, bits, value)</code> Write SDO 4x <code>int</code> <code>motor.nmt_write()</code> Write NMT <code>int</code> <code>motor.enable()</code> Enable the motor <code>motor.disable()</code> Disable the motor <p>When the motor is disabled, it will stop and ignore movement commands.</p>"},{"location":"module_reference/#dunkermotor","title":"DunkerMotor","text":"<p>This module controls dunkermotoren motor via CANOpen.</p> Constructor Description Arguments <code>motor = DunkerMotor(can, node_id)</code> CAN module and node ID (1..127) CAN module, <code>int</code> Properties Description Data type <code>motor.speed</code> Motor speed (meters per second) <code>float</code> <code>motor.voltage_logic</code> Voltage logic (V) <code>float</code> <code>motor.voltage_power</code> Voltage power (V) <code>float</code> <code>motor.m_per_turn</code> Meters per turn <code>float</code> <code>motor.reversed</code> Reverse motor direction <code>bool</code> <code>motor.enabled</code> Whether the motor is enabled <code>bool</code> <p>Note: To reduce bandwidth, voltages are only queried when explicitly requested by calling <code>update_voltages()</code>.</p> Methods Description Arguments <code>motor.speed(speed)</code> Move with given <code>speed</code> (m/s) <code>float</code> <code>motor.enable()</code> Enable motor <code>motor.disable()</code> Disable motor <code>motor.sdo_read(index[, subindex])</code> Read SDO 2x <code>int</code> <code>motor.sdo_write(index, subindex, bits, value)</code> Write SDO 4x <code>int</code> <code>motor.update_voltages()</code> Update voltages <code>motor.enable()</code> Enable the Motor <code>motor.disable()</code> Disable the Motor <p>When the motor is disabled, it will freewheel and ignore movement commands.</p>"},{"location":"module_reference/#dunkerwheels","title":"DunkerWheels","text":"<p>The DunkerWheels module combines two DunkerMotor modules and provides odometry and steering for differential wheeled robots.</p> Constructor Description Arguments <code>wheels = DunkerWheels(left_motor, right_motor)</code> left and right motors two DunkerMotor modules Properties Description Data type <code>wheels.width</code> Wheel distance (m) <code>float</code> <code>wheels.linear_speed</code> Forward speed (m/s) <code>float</code> <code>wheels.angular_speed</code> Turning speed (rad/s) <code>float</code> <code>wheels.enabled</code> Whether the wheels are enabled <code>bool</code> Methods Description Arguments <code>wheels.speed(linear, angular)</code> Move with <code>linear</code>/<code>angular</code> speed (m/s, rad/s) <code>float</code>, <code>float</code> <code>wheels.enable()</code> Enable both motors <code>wheels.disable()</code> Disable both motors <p>When the wheels are disabled, they will freewheel and ignore movement commands.</p>"},{"location":"module_reference/#analog-input","title":"Analog Input","text":"<p>This module is designed for reading analog voltages and converting them to digital values using the ESP32's ADC units. For detailed specifications of the ESP32 ADC modules, including attenuation levels, voltage range mappings, and GPIO-to-channel mapping, check the ESP32 documentation.</p> Constructor Description Arguments <code>analog = Analog(unit, channel[, attenuation])</code> unit, channel and attenuation level (dB) <code>int</code>, <code>int</code>, <code>float</code> <p>Possible attenuation levels are 0, 2.5, 6, and 12 dB. The default attenuation level is 12 dB.</p> Properties Description Data type <code>raw</code> raw measurement value (0-4095) <code>int</code> <code>voltage</code> voltage (V) <code>float</code>"},{"location":"module_reference/#expander","title":"Expander","text":"<p>The expander module allows communication with another microcontroller connected via serial.</p> Constructor Description Arguments <code>expander = Expander(serial[, boot, enable])</code> Serial module and boot/enable pins Serial module, 2x <code>int</code> Methods Description Arguments <code>expander.run(command)</code> Run any <code>command</code> on the other microcontroller <code>string</code> <code>expander.disconnect()</code> Disconnect serial connection and pins <code>expander.flash([force])</code> Flash other microcontroller with own binary data <code>bool</code> <code>expander.restart()</code> Restart other microcontroller <p>The <code>flash()</code> method requires the <code>boot</code> and <code>enable</code> pins to be defined. The optional <code>force</code> argument skips the default check whether certain strapping pins are set correctly.</p> <p>The <code>disconnect()</code> method might be useful to access the other microcontroller on UART0 via USB while still being physically connected to the main microcontroller.</p> <p>Note that the expander forwards all other method calls to the remote core module, e.g. <code>expander.info()</code>.</p> Properties Description Data type <code>boot_timeout</code> Time to wait for other microcontroller to boot (s) <code>float</code> <code>ping_interval</code> Time between pings (s) <code>float</code> <code>ping_timeout</code> Time before timing out (s) <code>float</code> <code>is_ready</code> Whether the remote module has booted and is ready <code>bool</code> <code>last_message_age</code> Time since last message from other microcontroller (ms) <code>int</code>"},{"location":"module_reference/#proxy","title":"Proxy","text":"<p>-- This module is mainly for internal use with the expander module. --</p> <p>Proxy modules serve as handles for remote modules running on another microcontroller. Declaring a module <code>x = Proxy()</code> will allow formulating rules like <code>when x.level == 0 then ...</code>. It will receive property values from a remote module with the same name <code>x</code>, e.g. an input signal level. Note that the remote module has to have turned on broadcasting: <code>x.broadcast()</code>.</p> Constructor <code>module = Proxy()</code> <p>Note that the proxy module forwards all method calls to the remote module.</p> Properties Description Data type <code>is_ready</code> Whether the remote module has booted and is ready <code>bool</code>"},{"location":"tools/","title":"Tools","text":""},{"location":"tools/#installation","title":"Installation","text":""},{"location":"tools/#flash","title":"Flash","text":"<p>To install Lizard on your ESP32 run</p> <pre><code>sudo ./flash.py [&lt;device_path&gt;]\n</code></pre> <p>Note that flashing may require root access (hence the sudo). The command also does not work while the serial interface is busy communicating with another process.</p>"},{"location":"tools/#robot-brain","title":"Robot Brain","text":"<p>The <code>flash.py</code> script can also upload firmware on a Robot Brain where the microcontroller is connected to the pin header of an NVIDIA Jetson computer.</p>"},{"location":"tools/#interaction","title":"Interaction","text":""},{"location":"tools/#serial-monitor","title":"Serial Monitor","text":"<p>Use the serial monitor to read the current output and interactively send Lizard commands to the microcontroller.</p> <pre><code>./monitor.py [&lt;device_path&gt;]\n</code></pre> <p>You can also use an SSH monitor to access a microcontroller via SSH:</p> <pre><code>./monitor_ssh.sh &lt;user@host&gt;\n</code></pre> <p>Note that the serial monitor cannot communicate while the serial interface is busy communicating with another process.</p>"},{"location":"tools/#configure","title":"Configure","text":"<p>Use the configure script to send a new startup script to the microcontroller.</p> <pre><code>./configure.py &lt;config_file&gt; &lt;device_path&gt;\n</code></pre> <p>Note that the configure script cannot communicate while the serial interface is busy communicating with another process.</p>"},{"location":"tools/#development","title":"Development","text":""},{"location":"tools/#prepare-for-development","title":"Prepare for Development","text":"<p>Install Python requirements:</p> <pre><code>python3 -m pip install -r requirements.txt\n</code></pre> <p>Install UART drivers: https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers</p> <p>Get all sub modules:</p> <pre><code>git submodule update --init --recursive\n</code></pre>"},{"location":"tools/#compile-lizard","title":"Compile Lizard","text":"<p>After making changes to the Lizard language definition or its C++ implementation, you can use the compile script to generate a new parser and executing the compilation in an Espressif IDF Docker container.</p> <pre><code>./compile.sh\n</code></pre> <p>To upload the compiled firmware you can use the <code>./flash.py</code> command described above.</p>"},{"location":"tools/#backtrace","title":"Backtrace","text":"<p>In case Lizard terminates with a backtrace printed to the serial terminal, you can use the following script to print corresponding source code lines.</p> <pre><code>./backtrace.sh &lt;addresses&gt;\n</code></pre> <p>Note that the script assumes Espressif IDF tools being installed at <code>~/esp/esp-tools_4.4/</code> and a compiled ELF file being located at <code>build/lizard.elf</code>.</p>"},{"location":"tools/#releasing","title":"Releasing","text":"<p>To build a new release, tag the commit with a \"v\" prefix, for example \"v0.1.4\". A GitHub action will build the binary and create a new release. After creation you can fill in a description if necessary.</p>"}]}