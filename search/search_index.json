{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lizard","text":"<p>Lizard is a domain-specific language to define hardware behavior. It is intended to run on embedded systems which are connected to motor controllers, sensors etc. Most of the time it is used in combination with a higher level engine like ROS or RoSys. You can think of the microcontroller as the machine's lizard brain which ensures basic safety and performs all time-critical actions.</p> <p>The idea is to not compile and deploy specific C++ code for every new hardware requirement. Instead you simply write your commands in a text-based language which can be changed on the fly.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Shell-like input and output over serial communication to ease the development</li> <li>Quick and resource-efficient execution on embedded hardware</li> <li>Built-in checksums to detect transmission errors</li> <li>Safety conditions that are checked continuously</li> <li>Ability to work across multiple microcontrollers</li> <li>Human-readable and easy-to-type (like Python)</li> <li>Persistent \"startup\" commands to apply configuration after boot</li> </ul>"},{"location":"#concept","title":"Concept","text":"<p>Lizard consists of individual hardware modules that are either defined in a persistent startup script or interactively via console input. Each module has a name, a number of required or optional constructor arguments and possibly a step function as well as a number of properties.</p> <p>Furthermore, Lizard allows to define rules, possibly asynchronous routines and variables. A routine is simply a collection of Lizard statements. If a rule's condition evaluates to true, the corresponding routine is started. Conditions can involve variables, module properties and constant expressions.</p> <p>One <code>core</code> module is automatically defined first. It provides interaction with the microcontroller itself, e.g. reading the system's time or causing a restart.</p> <p>During a main loop Lizard repeatedly performs the following tasks:</p> <ol> <li>Read and evaluate input from the serial interface.</li> <li>Run the step functions of each module. (The <code>core</code> module is evaluated last.)</li> <li>Check all rules and execute associated routines.</li> <li>Advance routines that are already running and waiting for certain conditions.</li> </ol>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#turn-on-an-led","title":"Turn on an LED","text":"<p>Create a new LED \"green\" at pin 14 and turn it on:</p> <pre><code>green = Output(14)\ngreen.on()\n</code></pre>"},{"location":"examples/#read-a-button","title":"Read a button","text":"<p>Create a button \"b1\" at pin 25 with internal pull-up resistor and read its value:</p> <pre><code>b1 = Input(25)\nb1.pullup()\nb1.level\n</code></pre>"},{"location":"examples/#write-a-persistent-startup-script","title":"Write a persistent startup script","text":"<p>Clear the persistent storage, configure a button and an LED, write the new startup script to the persistent storage, restart the microcontroller with these two new modules and print the stored configuration:</p> <pre><code>!-\n!+green = Output(14)\n!+b1 = Input(25)\n!.\ncore.restart()\n!?\n</code></pre>"},{"location":"examples/#define-a-rule","title":"Define a rule","text":"<p>Create an LED \"red\", a button \"b1\" with pull-up resistor as well as a condition \"c1\" that turns off the LED as soon as the button is pressed:</p> <pre><code>red = Output(14)\nred.on()\nb1 = Input(25)\nb1.pullup()\nwhen b1.level == 0 then red.off(); end\n</code></pre>"},{"location":"examples/#create-a-shadow-module","title":"Create a shadow module","text":"<p>Create a \"green\" LED that shadows a \"red\" LED, i.e. will receive a copy of each command:</p> <pre><code>green = Output(13)\nred = Output(14)\nred.shadow(green)\n</code></pre>"},{"location":"examples/#use-a-port-expander","title":"Use a port expander","text":"<p>Create a serial connection as well as a port expander with an LED at pin 15 and turn it on:</p> <pre><code>serial = Serial(26, 27, 11500, 1)\nexpander = Expander(serial, 32, 33)\nled = expander.Output(15)\nled.on()\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<ol> <li>Download and unpack the zip file of the latest release.</li> <li>Attach an Espressif ESP32 microcontroller via serial to your computer.</li> <li>Run <code>sudo ./flash.py /dev/&lt;serial device name&gt;</code> to install Lizard on the ESP32.</li> </ol>"},{"location":"getting_started/#try-out","title":"Try Out","text":"<p>You can launch an interactive shell with <code>./monitor.py</code> to try out configurations and watch Lizard outputs (see tools for more details). To verify that the communication is working, use one of the following commands to generate some output:</p> <pre><code>core.info()\ncore.millis\ncore.print(\"Hello, Lizard!\")\n</code></pre> <p>See the module reference for other commands.</p> <p>To try out individual modules, you can get their current properties or unmute them for continuous output, e.g.:</p> <pre><code>estop = Input(34)\nestop.level\nestop.unmute()\n</code></pre>"},{"location":"getting_started/#wiring","title":"Wiring","text":"<p>Of course you should connect the ESP32 to some hardware you want to control. From basic pins like LEDs (see Output) and buttons (see Input) to communication via CAN and control of stepper motors.</p>"},{"location":"getting_started/#startup-script","title":"Startup Script","text":"<p>You can create a startup script for rules which should be directly applied after boot of the microcontroller. Simply write the commands into a file like <code>on_startup.lizard</code> and set them with</p> <pre><code>./configure.py on_startup.lizard /dev/&lt;serial device name&gt;\n</code></pre> <p>See Tools for more details.</p>"},{"location":"language/","title":"The Lizard Language","text":""},{"location":"language/#statements","title":"Statements","text":"<p>Statements are input via the command-line interface or stored in the startup script on the microcontroller. The following statement types are currently supported.</p> <p>Expressions</p> <p>An expression can be a constant value, a variable, a module property, an arithmetic or logical expression as well as various combinations:</p> <pre><code>true\n42\n3.14\n\"Hello world\"\nled\nbutton.level\n1 + (2 - 3 * 4)**5\n1 == 2 or (x == 4 and button.level == 0)\n</code></pre> <p>Expressions can be assigned to variables, used in conditions and passed to constructors, method calls or routine calls. Plain expression statements print their result to the command line.</p> <p>Variables: declaration and assignment</p> <p>New variables need to be explicitly declared with a data type:</p> <pre><code>int i\n</code></pre> <p>They can be immediately initialized:</p> <pre><code>int i = 1\n</code></pre> <p>Otherwise they have an initial value of <code>false</code>, <code>0</code>, <code>0.0</code> or <code>\"\"</code>, respectively.</p> <p>Variables can be assigned a new value of compatible data type:</p> <pre><code>i = 2\n</code></pre> <p>Modules: constructors, method calls and property assignments</p> <p>Constructors are used to create module instances:</p> <pre><code>led = Output(15)\n</code></pre> <p>See the module reference for more details about individual modules and their argument lists.</p> <p>Constructors can also be used with expander modules to instantiate a remote module that can be controlled from the main microcontroller:</p> <pre><code>led = expander.Output(15)\n</code></pre> <p>You can call module methods as follows:</p> <pre><code>led.on()\n</code></pre> <p>Some module properties are meant to be written to:</p> <pre><code>motor.reversed = true\n</code></pre> <p>Routines: definition and call</p> <p>Routines have a name and contain a list of actions:</p> <pre><code>let all_on do\n    green.on()\n    red.on()\nend\n</code></pre> <p>They can be called similar to module methods:</p> <pre><code>all_on()\n</code></pre> <p>Rules: definition</p> <p>Rules execute a list of actions when a condition is met:</p> <pre><code>when button.level == 0 then\n    core.print(\"Off!\")\n    led.off()\nend\n</code></pre> <p>In contrast to an if-statement known from other languages a when-condition is checked in every cycle of Lizard's main loop. Whenever the condition is true, the actions are executed.</p> <p>Note that actions can be asynchronous. If there are still actions running asynchronously, a truthy condition is ignored.</p>"},{"location":"language/#actions","title":"Actions","text":"<p>Routines and rules contain a list of actions.</p> <p>Method and routine calls</p> <p>Like with a method call statement, you can call methods and routines with an action:</p> <pre><code>when clicked then\n    core.print(\"On!\")\n    all_on()\nend\n</code></pre> <p>Property and variable assignments</p> <p>Like with the corresponding assignment statements, you can assign properties and variables with an action as well:</p> <pre><code>when i &gt; 0 then\n    i = 0\n    core.debug = true\nend\n</code></pre> <p>Await conditions and routines</p> <p>In contrast to statements, actions can await conditions, causing the execution of subsequent actions to wait until the condition is met.</p> <pre><code>int t\nlet blink do\n    t = core.millis\n    led.on()\n    await core.millis &gt; t + 1000\n    led.off()\nend\n</code></pre> <p>Similarly, actions can await asynchronous routines, causing subsequent actions to wait until a routine is completed.</p> <pre><code>when button.level == 0 then\n    core.print(\"Blink...\")\n    await blink()\n    core.print(\"Done.\")\nend\n</code></pre>"},{"location":"language/#data-types","title":"Data types","text":"<p>Lizard currently supports five data types:</p> Data type Example Range boolean <code>bool b = true</code> <code>false</code>, <code>true</code> integer number <code>int i = 0</code> 64-bit unsigned integer floating point number <code>float f = 0.0</code> 64-bit float string <code>str s = \"foo\"</code> identifier <code>led = Output(15)</code> <p>Note that identifiers cannot be created via variable declarations, but only via constructors.</p> <p>Implicit conversion only happens from integers to floating point numbers:</p> <pre><code>int i = 42\nfloat f = i + 3.14\n</code></pre>"},{"location":"language/#whitespace-comments-and-line-breaks","title":"Whitespace, comments and line breaks","text":"<p>Tabs and spaces are treated as whitespace.</p> <p>Blank lines are interpreted as no-op and do nothing.</p> <p>Line comments start with <code>#</code>.</p> <p>Multiple statements or actions are separated with <code>;</code> or a newline.</p>"},{"location":"language/#control-commands","title":"Control commands","text":"<p>Lines with a leading <code>!</code> can indicate one of the following control commands.</p> Command Meaning <code>!+abc</code> Add <code>abc</code> to the startup script <code>!-abc</code> Remove lines starting with <code>abc</code> from the startup script <code>!?</code> Print the startup script <code>!.</code> Write the startup script to non-volatile storage <code>!!abc</code> Interpret <code>abc</code> as Lizard code <code>!\"abc</code> Print <code>abc</code> to the command-line <p>Note that the commands <code>!+</code>, <code>!-</code> and <code>!?</code> affect the startup script in RAM, which is only written to non-volatile storage with the <code>!.</code> command.</p> <p>Input from the default command-line interface UART0 is usually interpreted as Lizard code; input from a port expander is usually printed to the command-line on UART0. This behavior can be changed using <code>!!</code> and <code>!\"</code>.</p>"},{"location":"machine_safety/","title":"Machine Safety","text":"<p>Lizard implements the following features to increase machine safety.</p>"},{"location":"machine_safety/#checksums","title":"Checksums","text":"<p>Each line sent via the command-line interface can and should be followed by a checksum. Lizard will omit any lines with incorrect checksums. Any output is as well sent with a checksum.</p> <p>The 8-bit checksum is computed as the bitwise XOR of all characters excluding the newline character and written as a two-digit hex number (with leading zeros) separated with an <code>@</code> character, for example:</p> Line Bitwise XOR Result <code>1 + 2</code> 0x31 ^ 0x20 ^ 0x2b ^ 0x20 ^ 0x32 = 0x28 <code>1 + 2@28</code>"},{"location":"machine_safety/#keep-alive-signal","title":"Keep-alive signal","text":"<p>The <code>core</code> module provides a property <code>last_message_age</code>, which holds the time in milliseconds since the last input message was received from UART0, parsed and successfully interpreted. It allows formulating rules that stop critical hardware modules when the connection to the host system is lost.</p> <p>The following example stops a motor when there is no serial communication for 500 ms:</p> <pre><code>when core.last_message_age &gt; 500 then motor.stop(); end\n</code></pre>"},{"location":"module_reference/","title":"Module Reference","text":"<p>All Lizard modules have the following methods in common.</p> Methods Description <code>module.mute()</code> Turn output off <code>module.unmute()</code> Turn output on <code>module.shadow()</code> Send all method calls also to another module <code>module.broadcast()</code> Regularly send properties to another microcontroller (for internal use) <p>Shadows are useful if multiple modules should behave exactly the same, e.g. two actuators that should always move synchronously.</p> <p>The <code>broadcast</code> method is used internally with port expanders.</p>"},{"location":"module_reference/#core","title":"Core","text":"<p>The core module encapsulates various properties and methods that are related to the microcontroller itself. It is automatically created right after the boot sequence.</p> Properties Description Data type <code>core.debug</code> Whether to output debug information to the command line <code>bool</code> <code>core.millis</code> Time since booting the microcontroller (ms) <code>int</code> <code>core.heap</code> Free heap memory (bytes) <code>int</code> Methods Description Arguments <code>core.restart()</code> Restart the microcontroller <code>core.version()</code> Show lizard version <code>core.info()</code> Show lizard version, compile time and IDF version <code>core.print(...)</code> Print arbitrary arguments to the command line arbitrary <code>core.output(format)</code> Define the output format <code>str</code> <code>core.startup_checksum()</code> Show 16-bit checksum of the startup script <p>The output <code>format</code> is a string with multiple space-separated elements of the pattern <code>&lt;module&gt;.&lt;property&gt;[:&lt;precision&gt;]</code> or <code>&lt;variable&gt;[:&lt;precision&gt;]</code>. The <code>precision</code> is an optional integer specifying the number of decimal places for a floating point number. For example, the format <code>\"core.millis input.level motor.position:3\"</code> might yield an output like <code>\"92456 1 12.789</code>.</p>"},{"location":"module_reference/#bluetooth","title":"Bluetooth","text":"<p>Lizard can receive messages via Bluetooth Low Energy, and also send messages in return to a connected device. Simply create a Bluetooth module with a device name of your choice.</p> Constructor Description Arguments <code>bluetooth = Bluetooth(device_name)</code> initialize bluetooth with advertised <code>device_name</code> <code>str</code> <code>bluetooth.send(data)</code> send <code>data</code> via notification <code>str</code> <p>Lizard will offer a service 23014CCC-4677-4864-B4C1-8F772B373FAC and a characteristic 37107598-7030-46D3-B688-E3664C1712F0 that allows writing Lizard statements like on the command line. On a second characteristic 19f91f52-e3b1-4809-9d71-bc16ecd81069 notifications will be emitted when <code>send(data)</code> is executed.</p>"},{"location":"module_reference/#input","title":"Input","text":"<p>The input module is associated with a digital input pin that is be connected to a pushbutton, sensor or other input signal.</p> Constructor Description Arguments <code>input = Input(pin)</code> <code>pin</code> is the corresponding GPIO number <code>int</code> Properties Description Data type <code>input.level</code> Current signal level (0 or 1) <code>int</code> <code>input.change</code> Level change since last cycle (-1..1) <code>int</code> <code>input.inverted</code> Inverts the active property if true <code>bool</code> <code>input.active</code> Current active state of the input <code>bool</code> Methods Description <code>input.get()</code> Output the current level <code>input.pullup()</code> Add an internal pull-up resistor <code>input.pulldown()</code> Add an internal pull-down resistor <code>input.pulloff()</code> Remove internal pull resistor"},{"location":"module_reference/#output","title":"Output","text":"<p>The output module is associated with a digital output pin that is connected to an LED, actuator or other output signal.</p> Constructor Description Arguments <code>output = Output(pin)</code> <code>pin</code> is the corresponding GPIO number <code>int</code> Properties Description Data type <code>output.level</code> Current signal level (0 or 1) <code>int</code> <code>output.change</code> Level change since last cycle (-1..1) <code>int</code> Methods Description Arguments <code>output.on()</code> Set the output pin high <code>output.off()</code> Set the output pin low <code>output.level(value)</code> Set the output level to the given <code>value</code> <code>bool</code> <code>output.pulse(interval[, duty_cycle])</code> Switch output on and off <code>float</code>s <p>The <code>pulse()</code> method allows pulsing an output with a given interval in seconds and an optional duty cycle between 0 and 1 (0.5 by default). Note that the pulsing frequency is limited by the main loop to around 20 Hz.</p>"},{"location":"module_reference/#pwm-output","title":"PWM Output","text":"<p>The PWM output module is associated with a digital output pin that is connected to an LED, actuator or other output signal.</p> Constructor Description Arguments <code>pwm = PwmOutput(pin)</code> <code>pin</code> is the corresponding GPIO number <code>int</code> Properties Description Data type <code>output.duty</code> Duty cycle (8 bit: 0..256, default: 128) <code>int</code> <code>output.frequency</code> Frequency (Hz, default: 1000) <code>int</code> Methods Description Arguments <code>output.on()</code> Turn on the PWM signal <code>output.off()</code> Turn off the PWM signal"},{"location":"module_reference/#mcp23017-port-expander","title":"MCP23017 Port Expander","text":"<p>The MCP23017 allows controlling up to 16 general purpose input or output pins via I2C.</p> Constructor Description Arguments <code>mcp = Mcp23017([port[, sda[, scl[, address[, clk_speed]]]]])</code> See below <code>int</code>s <p>The constructor expects up to five arguments:</p> <ul> <li><code>port</code>: 0 or 1, since the ESP32 has two I2C ports (default: 0)</li> <li><code>sda</code>: SDA pin (default: 21)</li> <li><code>scl</code>: SCL pin (default: 22)</li> <li><code>address</code>: client address of the MCP (0x20..0x28, default: 0x20)</li> <li><code>clk_speed</code>: I2C clock speed (default: 100000)</li> </ul> Properties Description Data type <code>mcp.levels</code> Levels of all 16 pins <code>int</code> <code>mcp.inputs</code> Input mode of all 16 pins <code>int</code> <code>mcp.pullups</code> Pull-up resistors for all 16 pins <code>int</code> <p>The properties <code>levels</code>, <code>inputs</code> and <code>pullups</code> contain binary information for all 16 pins in form of a 16 bit unsigned integer.</p> Methods Description Arguments <code>mcp.levels(value)</code> Set levels of all 16 pins <code>int</code> <code>mcp.inputs(value)</code> Set input mode of all 16 pins <code>int</code> <code>mcp.pullups(value)</code> Set pull-up resistors for all 16 pins <code>int</code> <p>The methods <code>levels()</code>, <code>inputs()</code> and <code>pullups()</code> expect a 16 bit unsigned integer <code>value</code> containing binary information for all 16 pins.</p> <p>Use <code>inputs()</code> to configure input and output pins, e.g. <code>inputs(0xffff)</code> all inputs or <code>inputs(0x0000)</code> all outputs. While <code>levels()</code> will only affect output pins, <code>pullups()</code> will only affect the levels of input pins.</p> <p>Using an MCP23017 port expander module you can not only access individual pins. You can also instantiate the following modules passing the <code>mcp</code> instance as the first argument:</p> <ul> <li>Input: <code>input = Input(mcp, pin)</code></li> <li>Output: <code>output = Output(mcp, pin)</code></li> <li>Linear motor: <code>motor = LinearMotor(mcp, move_in, move_out, end_in, end_out)</code></li> </ul> <p>The pins <code>pin</code>, <code>move_in</code>, <code>move_out</code>, <code>end_in</code> and <code>end_out</code> are numbers from 0 to 15 referring to A0...A7 and B0...B7 on the MCP23017.</p>"},{"location":"module_reference/#imu","title":"IMU","text":"<p>The IMU module provides access to a Bosch BNO055 9-axis absolute orientation sensor. Currently, only reading the accelerometer is implemented.</p> Constructor Description Arguments <code>imu = Imu([port[, sda[, scl[, address[, clk_speed]]]]])</code> See below <code>int</code>s <p>The constructor expects up to five arguments:</p> <ul> <li><code>port</code>: 0 or 1, since the ESP32 has two I2C ports (default: 0)</li> <li><code>sda</code>: SDA pin (default: 21)</li> <li><code>scl</code>: SCL pin (default: 22)</li> <li><code>address</code>: client address of the MCP (0x28 or 0x29, default: 0x28)</li> <li><code>clk_speed</code>: I2C clock speed (default: 100000)</li> </ul> Properties Description Data type <code>imu.acc_x</code> acceleration in x direction (m/s^2) <code>float</code> <code>imu.acc_y</code> acceleration in y direction (m/s^2) <code>float</code> <code>imu.acc_z</code> acceleration in z direction (m/s^2) <code>float</code> <code>imu.roll</code> roll (degrees, see datasheet) <code>float</code> <code>imu.pitch</code> pitch (degrees, see datasheet) <code>float</code> <code>imu.yaw</code> yaw (degrees, see datasheet) <code>float</code> <code>imu.quat_w</code> quaternion component w <code>float</code> <code>imu.quat_x</code> quaternion component x <code>float</code> <code>imu.quat_y</code> quaternion component y <code>float</code> <code>imu.quat_z</code> quaternion component z <code>float</code> <code>imu.cal_sys</code> calibration of system (0 to 3) <code>float</code> <code>imu.cal_gyr</code> calibration of gyroscope (0 to 3) <code>float</code> <code>imu.cal_acc</code> calibration of accelerometer (0 to 3) <code>float</code> <code>imu.cal_mag</code> calibration of magnetometer (0 to 3) <code>float</code>"},{"location":"module_reference/#can-interface","title":"CAN interface","text":"<p>The CAN module allows communicating with peripherals on the specified CAN bus.</p> Constructor Description Arguments <code>can = Can(rx, tx, baud)</code> RX/TX pins and baud rate <code>int</code>, <code>int</code>, <code>int</code> Methods Description Arguments <code>can.send(node_id, d0, d1, d2, d3, d4, d5, d6, d7)</code> Send a frame with 8 data bytes 9x <code>int</code> <code>can.get_status()</code> Print the driver status <code>can.start()</code> Start the driver <code>can.stop()</code> Stop the driver <code>can.recover()</code> Recover the driver <p>The method <code>get_status()</code> prints the following information:</p> <ul> <li><code>state</code> (\"STOPPED\", \"RUNNING\", \"BUS_OFF\" or \"RECOVERING\"),</li> <li><code>msgs_to_tx</code>,</li> <li><code>msgs_to_rx</code>,</li> <li><code>tx_error_counter</code>,</li> <li><code>rx_error_counter</code>,</li> <li><code>tx_failed_count</code>,</li> <li><code>rx_missed_count</code>,</li> <li><code>rx_overrun_count</code>,</li> <li><code>arb_lost_count</code> and</li> <li><code>bus_error_count</code>.</li> </ul> <p>After creating a CAN module, the driver is started automatically. The <code>start()</code> and <code>stop()</code> methods are primarily for debugging purposes.</p>"},{"location":"module_reference/#serial-interface","title":"Serial interface","text":"<p>The serial module allows communicating with peripherals via the specified connection.</p> Constructor Description Arguments <code>serial = Serial(rx, tx, baud, num)</code> RX/TX pins, baud rate, UART number 4x <code>int</code> Methods Description Arguments <code>serial.send(b0, b1, b2, ...)</code> Send a number of bytes <code>int</code>s <code>serial.read()</code> Read and output current buffer <p>This module might be used by other modules that communicate with peripherals via serial. You can, however, unmute the serial module to have incoming messages printed to the command line instead of keeping them buffered for other modules.</p>"},{"location":"module_reference/#linear-motor","title":"Linear motor","text":"<p>This module controls a linear actuator via two output pins (move in, move out) and two input pins reading two limit switches (end in, end out).</p> Constructor Description Arguments <code>motor = LinearMotor(move_in, move_out, end_in, end_out)</code> motor control pins and limit switches 4x <code>int</code> Properties Description Data type <code>motor.in</code> Motor is in \"in\" position <code>bool</code> <code>motor.out</code> Motor is in \"out\" position <code>bool</code> Methods Description <code>motor.in()</code> Move in <code>motor.out()</code> Move out <code>motor.stop()</code> Stop motor"},{"location":"module_reference/#odrive-motor","title":"ODrive Motor","text":"<p>The ODrive motor module controls a motor using an ODrive motor controller.</p> Constructor Description Arguments <code>motor = ODriveMotor(can, can_id)</code> CAN module and node ID CAN module, <code>int</code> Properties Description Data type <code>motor.position</code> Motor position (meters) <code>float</code> <code>motor.tick_offset</code> Encoder tick offset <code>float</code> <code>motor.m_per_tick</code> Meters per encoder tick <code>float</code> <code>motor.reversed</code> Reverse motor direction <code>bool</code> Methods Description Arguments <code>motor.zero()</code> Set current position as zero position <code>motor.power(torque)</code> Move with given <code>torque</code> <code>float</code> <code>motor.speed(speed)</code> Move with given <code>speed</code> (m/s) <code>float</code> <code>motor.position(position)</code> Move to given <code>position</code> (m) <code>float</code> <code>motor.limits(speed, current)</code> Set speed (m/s) and current (A) limits <code>float</code>, <code>float</code> <code>motor.off()</code> Turn motor off (idle state)"},{"location":"module_reference/#odrive-wheels","title":"ODrive Wheels","text":"<p>The ODrive wheels module combines to ODrive motors and provides odometry and steering for differential wheeled robots.</p> Constructor Description Arguments <code>wheels = ODriveWheels(left_motor, left_motor)</code> Two ODrive motor modules two ODrive motor modules Properties Description Data type <code>wheels.width</code> wheel distance (m) <code>float</code> <code>wheels.linear_speed</code> Forward speed (m/s) <code>float</code> <code>wheels.angular_speed</code> Turning speed (rad/s) <code>float</code> <code>wheels.enabled</code> Whether motors react to commands <code>bool</code> Methods Description Arguments <code>wheels.power(left, right)</code> Move with torque per wheel <code>float</code>, <code>float</code> <code>wheels.speed(linear, angular)</code> Move with <code>linear</code>/<code>angular</code> speed (m/s, rad/s) <code>float</code>, <code>float</code> <code>wheels.off()</code> Turn both motors off (idle state) <p>When the wheels are not <code>enabled</code>, <code>power</code> and <code>speed</code> method calls are ignored. This allows disabling the wheels permanently by setting <code>enabled = false</code> in conjunction with calling the <code>off()</code> method. Now the vehicle can be pushed manually with motors turned off, without taking care of every line of code potentially re-activating the motors.</p>"},{"location":"module_reference/#rmd-motor","title":"RMD Motor","text":"<p>The RMD motor module controls a Gyems RMD motor via CAN.</p> Constructor Description Arguments <code>rmd = RmdMotor(can, motor_id, ratio)</code> CAN module, motor ID (1..8) and transmission ratio CAN module, <code>int</code>, <code>int</code> Properties Description Data type <code>rmd.position</code> Multi-turn motor position (deg) <code>float</code> <code>rmd.torque</code> Current torque <code>float</code> <code>rmd.speed</code> Current speed (deg/s) <code>float</code> <code>rmd.temperature</code> Current temperature (C) <code>float</code> <code>rmd.can_age</code> Time since last CAN message from motor (s) <code>float</code> Methods Description Arguments <code>rmd.power(torque)</code> Move with given <code>torque</code> (-32..32 A) <code>float</code> <code>rmd.speed(speed)</code> Move with given <code>speed</code> (deg/s) <code>float</code> <code>rmd.position(pos)</code> Move to and hold at <code>pos</code> (deg) <code>float</code> <code>rmd.position(pos, speed)</code> Move to and hold at <code>pos</code> (deg) with max. <code>speed</code> (deg/s) <code>float</code>, <code>float</code> <code>rmd.stop()</code> Stop motor (but keep operating state) <code>rmd.off()</code> Turn motor off (clear operating state) <code>rmd.hold()</code> Hold current position <code>rmd.get_pid()</code> Print PID parameters Kp/Ki for position/speed/torque loop <code>rmd.set_pid(...)</code> Set PID parameters Kp/Ki for position/speed/torque loop 6x <code>int</code> <code>rmd.get_acceleration()</code> Print acceleration (deg/s^2) <code>rmd.set_acceleration(...)</code> Set accelerations/decelerations for position/speed loop (deg/s^2) 4x <code>int</code> <code>rmd.clear_errors()</code> Clear motor error <code>rmd.zero()</code> Write position to ROM as zero position (see below) <p>The zero command</p> <p>The <code>zero()</code> method should be used with care! In contrast to other commands it blocks the main loop for up to 200 ms and requires restarting the motor to take effect. Furthermore, multiple writes will affect the chip life, thus it is not recommended to use it frequently.</p> <p>Set acceleration</p> <p>Although <code>get_acceleration()</code> prints only one acceleration per motor, <code>set_acceleration</code> distinguishes the following four parameters:</p> <ol> <li>acceleration for position mode</li> <li>deceleration for position mode</li> <li>acceleration for speed mode</li> <li>deceleration for speed mode</li> </ol> <p>You can pass <code>0</code> to skip parameters, i.e. to keep individual acceleration values unchanged.</p>"},{"location":"module_reference/#rmd-motor-pair","title":"RMD Motor Pair","text":"<p>The RMD motor pair module allows to synchronize two RMD motors.</p> Constructor Description Arguments <code>rmd = RmdPair(rmd1, rmd2)</code> Two RMD motor modules 2x RMD Motor module Properties Description Data type <code>rmd.v_max</code> Maximum speed (deg/s, default: 360) <code>float</code> <code>rmd.a_max</code> Maximum acceleration (deg/s\u00b2 (default: 10000) <code>float</code> Methods Description Arguments <code>rmd.move(x, y)</code> Move motor 1 to <code>x</code> and motor 2 to <code>x</code> 2x <code>float</code> <code>rmd.stop()</code> Stop motors (but keep operating state) <code>rmd.off()</code> Turn motors off (clear operating state) <code>rmd.hold()</code> Hold current positions <code>rmd.clear_errors()</code> Clear motor errors"},{"location":"module_reference/#roboclaw","title":"RoboClaw","text":"<p>The RoboClaw module serves as building block for more complex modules like RoboClaw motors. It communicates with a Basicmicro RoboClaw motor driver via serial.</p> Constructor Description Arguments <code>claw = RoboClaw(serial, address)</code> Serial module and address Serial module, <code>int</code> Properties Description Data type <code>claw.temperature</code> Board temperature (degrees Celsius) <code>float</code> <p>The temperature property is updated every 1 second.</p>"},{"location":"module_reference/#roboclaw-motor","title":"RoboClaw Motor","text":"<p>The RoboClaw motor module controls a motor using a RoboClaw module.</p> Constructor Description Arguments <code>motor = RoboClawMotor(claw, motor_id)</code> RoboClaw module and motor ID (1..2) RoboClaw module, <code>int</code> Properties Description Data type <code>motor.position</code> Multi-turn motor position (encoder ticks) <code>int</code> Methods Description Arguments <code>motor.power(torque)</code> Move with given <code>torque</code> (-1..1) <code>float</code> <code>motor.speed(speed)</code> Move with given <code>speed</code> (-32767..32767) <code>float</code> <code>motor.zero()</code> Store position as zero position"},{"location":"module_reference/#roboclaw-wheels","title":"RoboClaw Wheels","text":"<p>The RoboClaw wheels module combines two RoboClaw motors and provides odometry and steering for differential wheeled robots.</p> Constructor Description Arguments <code>wheels = RoboClawWheels(left_motor, left_motor)</code> left and right motors two RoboClaw motor modules Properties Description Data type <code>wheels.width</code> wheel distance (m) <code>float</code> <code>wheels.linear_speed</code> Forward speed (m/s) <code>float</code> <code>wheels.angular_speed</code> Turning speed (rad/s) <code>float</code> <code>wheels.m_per_tick</code> Meters per encoder tick <code>float</code> <code>wheels.enabled</code> Whether motors react to commands <code>bool</code> Methods Description Arguments <code>wheels.power(left, right)</code> Move with torque per wheel (-1..1) <code>float</code>, <code>float</code> <code>wheels.speed(linear, angular)</code> Move with <code>linear</code>/<code>angular</code> speed (m/s, rad/s) <code>float</code>, <code>float</code> <code>wheels.off()</code> Turn both motors off (idle state) <p>When the wheels are not <code>enabled</code>, <code>power</code> and <code>speed</code> method calls are ignored.</p>"},{"location":"module_reference/#stepper-motor","title":"Stepper Motor","text":"<p>The stepper motor module controls a stepper motor via \"step\" and \"direction\" pins. It uses the ESP LED Control API to generate pulses with sufficiently high frequencies and the Pulse Counter API to count steps.</p> Constructor Description Arguments <code>motor = StepperMotor(step, dir[, pu[, cp[, lt[, lc]]]])</code> Step and direction pins 6x <code>int</code> <p>The constructor arguments <code>pu</code> (pulse counter unit), <code>pc</code> (pulse counter channel), <code>lt</code> (LED timer) and <code>lc</code> (LED channel) are optional and default to 0. When using multiple stepper motors, they can be set to different values to avoid conflicts.</p> Properties Description Data type <code>motor.position</code> Motor position (steps) <code>int</code> <code>motor.speed</code> Motor speed (steps per second) <code>int</code> <code>motor.idle</code> Motor idle state <code>bool</code> Methods Description Arguments <code>motor.speed(speed[, acceleration])</code> Move with given <code>speed</code> 2x <code>float</code> <code>motor.position(position, speed[, acceleration])</code> Move to given <code>position</code> 3x <code>float</code> <code>motor.stop()</code> Stop <p>The optional acceleration argument defaults to 0, which starts and stops pulsing immediately.</p>"},{"location":"module_reference/#motor-axis","title":"Motor Axis","text":"<p>The motor axis module wraps a stepper motor and two limit switches. It prevents the motor from moving past the limits. But in contrast to a simple Lizard rule, it allows to actively move out of the limits when moving in the right direction.</p> Constructor Description Arguments <code>axis = MotorAxis(motor, limit1, limit2)</code> StepperMotor and Input modules 3 modules <p>Currently the motor axis module has no properties. To get the current position or speed, access the StepperMotor module instead.</p> Methods Description Arguments <code>motor.speed(speed[, acceleration])</code> Move with given <code>speed</code> 2x <code>float</code> <code>motor.position(position, speed[, acceleration])</code> Move to given <code>position</code> 3x <code>float</code> <code>motor.stop()</code> Stop"},{"location":"module_reference/#canopenmaster","title":"CanOpenMaster","text":"<p>The CanOpenMaster module sends periodic SYNC messages to all CANopen nodes. At creation, no messages are sent until <code>sync_interval</code> is set to a value greater than 0.</p> Constructor Description Arguments <code>co_master = CanOpenMaster(can)</code> CAN module CAN module Properties Description Data type <code>co_master.sync_interval</code> Amount of lizard steps inbetween each SYNC <code>int</code>"},{"location":"module_reference/#canopenmotor","title":"CanOpenMotor","text":"<p>The CanOpenMotor module implements a subset of commands necessary to control a motor implementing DS402. Positional and velocity units are currently undefined and must by manually measured. Once the configuration sequence has finished, current status, position and velocity are queried on every SYNC.</p> Constructor Description Arguments <code>motor = CanOpenMotor(can, node_id)</code> CAN module and node ID (1..127) <code>CAN module</code>, <code>int</code> Methods Description Arguments <code>motor.enter_pp_mode(velo)</code> Set 402 operating mode to profile position, halt off, and target velocity to <code>velo</code> <code>int</code> <code>motor.enter_pv_mode()</code> Set 402 operating mode to profile velocity, halt on, and target velocity to <code>velo</code> <code>int</code> <code>motor.set_target_position(pos)</code> Set target position to <code>pos</code> (signed). [pp mode] <code>int</code> <code>motor.commit_target_position()</code> Instruct motor to move to previously set target position. [pp mode] <code>motor.set_target_velocity(velo)</code> Set target velocity to <code>velo</code>. Absolute for pp mode, signed for pv mode <code>int</code> <code>motor.set_ctrl_halt(mode)</code> Latches / resets the \"halt\" bit and sends the updated control word to the node <code>bool</code> <code>motor.set_ctrl_enable(mode)</code> Latches / resets the \"enable operation\" bit and sends an updated control word to the node <code>bool</code> <code>motor.reset_fault()</code> Clear any faults (like positioning errors). Implicitly sets the \"halt\" bit. <code>motor.sdo_read(index)</code> Performs an SDO read at index <code>index</code> and sub index <code>0x00</code> <code>int</code> Properties Description Data type <code>initialized</code> Concurrent init sequence has finished, motor is ready <code>bool</code> <code>last_heartbeat</code> Time in \u00b5s since bootup when last heartbeat was received <code>int</code> <code>is_booting</code> Node is in booting state <code>bool</code> <code>is_preoperational</code> Node is in pre-operational state <code>bool</code> <code>is_operational</code> Node is in operational state <code>bool</code> <code>actual_position</code> Motor position at last SYNC <code>int</code> <code>position_offset</code> Offset implicitly added to target/reported position <code>int</code> <code>actual_velocity</code> Motor velocity at last SYNC <code>int</code> <code>status_enabled</code> Operation enabled bit of status word since last SYNC <code>bool</code> <code>status_fault</code> Fault bit of status word since last SYNC <code>bool</code> <code>status_target_reached</code> Target reached bit of status word since last SYNC <code>bool</code> <code>ctrl_enable</code> Latched operation enable bit of every sent control word <code>bool</code> <code>ctrl_halt</code> Latched halt bit of every sent control word <code>bool</code> <p>Configuration sequence</p> <p>After creation of the module, the configuration is stepped through automatically on each heartbeat; once finished, the <code>initialized</code> attribute is set to <code>true</code>. Note that for runtime variables (actual position, velocity, and status bits) to be updated, a CanOpenMaster module must exist and be sending periodic SYNCs.</p> <p>Target position sequence</p> <p>Note: The target velocity must be positive regardless of target point direction. The halt bit is cleared when entering pp, though it can be set at any point during moves to effectively apply brakes.</p> <pre><code>// First time, assuming motor is disabled and not in pp mode\nmotor.set_ctrl_enable(true)\nmotor.enter_pp_mode(&lt;some positive velocity&gt;)\n\n// All further set points only need these\nmotor.set_target_position(&lt;some position&gt;)\nmotor.commit_target_position()\n</code></pre> <p>Target velocity sequence</p> <p>Unlike in the profile position mode, here the sign of the velocity does controls the direction. The halt bit is set when entering pv. To start moving, clear it (and set again to stop).</p> <pre><code>// First time, assuming motor is disabled and not in pv mode\nmotor.set_ctrl_enable(true)\nmotor.enter_pv_mode(&lt;some signed velocity&gt;)\n\n// Further movements only need these\nmotor.set_ctrl_halt(false)\n// await some condition\nmotor.set_ctrl_halt(true)\n</code></pre>"},{"location":"module_reference/#expander","title":"Expander","text":"<p>The expander module allows communication with another microcontroller connected via serial.</p> Constructor Description Arguments <code>expander = Expander(serial, boot, enable)</code> Serial module and boot/enable pins Serial module, 2x <code>int</code> Methods Description Arguments <code>expander.run(command)</code> Run any <code>command</code> on the other microcontroller <code>string</code> <code>expander.disconnect()</code> Disconnect serial connection and pins <code>expander.flash()</code> Flash other microcontroller with own binary data <p>The <code>disconnect()</code> method might be useful to access the other microcontroller on UART0 via USB while still being physically connected to the main microcontroller.</p> <p>Note that the expander forwards all other method calls to the remote core module, e.g. <code>expander.info()</code>.</p>"},{"location":"module_reference/#proxy","title":"Proxy","text":"<p>-- This module is mainly for internal use with the expander module. --</p> <p>Proxy modules serve as handles for remote modules running on another microcontroller. Declaring a module <code>x = Proxy()</code> will allow formulating rules like <code>when x.level == 0 then ...</code>. It will receive property values from a remote module with the same name <code>x</code>, e.g. an input signal level. Note that the remote module has to have turned on broadcasting: <code>x.broadcast()</code>.</p> Constructor <code>module = Proxy()</code> <p>Note that the proxy module forwards all method calls to the remote module.</p>"},{"location":"tools/","title":"Tools","text":""},{"location":"tools/#installation","title":"Installation","text":""},{"location":"tools/#flash","title":"Flash","text":"<p>To install Lizard on your ESP32 run</p> <pre><code>sudo ./flash.py [&lt;device_path&gt;]\n</code></pre> <p>Note that flashing may require root access (hence the sudo). The command also does not work while the serial interface is busy communicating with another process.</p>"},{"location":"tools/#robot-brain","title":"Robot Brain","text":"<p>The <code>flash.py</code> script can also upload firmware on a Robot Brain where the microcontroller is connected to the pin header of an NVIDIA Jetson computer.</p>"},{"location":"tools/#interaction","title":"Interaction","text":""},{"location":"tools/#serial-monitor","title":"Serial Monitor","text":"<p>Use the serial monitor to read the current output and interactively send Lizard commands to the microcontroller.</p> <pre><code>./monitor.py [&lt;device_path&gt;]\n</code></pre> <p>You can also use an SSH monitor to access a microcontroller via SSH:</p> <pre><code>./monitor_ssh.sh &lt;user@host&gt;\n</code></pre> <p>Note that the serial monitor cannot communicate while the serial interface is busy communicating with another process.</p>"},{"location":"tools/#configure","title":"Configure","text":"<p>Use the configure script to send a new startup script to the microcontroller.</p> <pre><code>./configure.py &lt;config_file&gt; &lt;device_path&gt;\n</code></pre> <p>Note that the configure script cannot communicate while the serial interface is busy communicating with another process.</p>"},{"location":"tools/#development","title":"Development","text":""},{"location":"tools/#prepare-for-development","title":"Prepare for Development","text":"<p>Install Python requirements:</p> <pre><code>python3 -m pip install -r requirements.txt\n</code></pre> <p>Install UART drivers: https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers</p> <p>Get all sub modules:</p> <pre><code>git submodule update --init --recursive\n</code></pre>"},{"location":"tools/#compile-lizard","title":"Compile Lizard","text":"<p>After making changes to the Lizard language definition or its C++ implementation, you can use the compile script to generate a new parser and executing the compilation in an Espressif IDF Docker container.</p> <pre><code>./compile.sh\n</code></pre> <p>To upload the compiled firmware you can use the <code>./flash.py</code> command described above.</p>"},{"location":"tools/#backtrace","title":"Backtrace","text":"<p>In case Lizard terminates with a backtrace printed to the serial terminal, you can use the following script to print corresponding source code lines.</p> <pre><code>./backtrace.sh &lt;addresses&gt;\n</code></pre> <p>Note that the script assumes Espressif IDF tools being installed at <code>~/esp/esp-tools_4.4/</code> and a compiled ELF file being located at <code>build/lizard.elf</code>.</p>"},{"location":"tools/#releasing","title":"Releasing","text":"<p>To build a new release, tag the commit with a \"v\" prefix, for example \"v0.1.4\". A GitHub action will build the binary and create a new release. After creation you can fill in a description if necessary.</p>"}]}